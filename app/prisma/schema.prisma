// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User Model (Admin + Plugin-Nutzer)
model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  password      String
  role          UserRole  @default(USER)
  
  // E-Mail-Verifizierung
  emailVerified Boolean   @default(false)
  verificationToken String? @unique
  verificationTokenExpiry DateTime?
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  // Relations
  installations  Installation[]
  sessions       Session[]
  invoices       Invoice[]
  supportTickets SupportTicket[]
  licenses       License[]
  
  @@map("users")
}

enum UserRole {
  ADMIN
  USER
}

// Session Model (für Auth)
model Session {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("sessions")
}

// Installation Model (Plugin-Installationen)
model Installation {
  id            String   @id @default(cuid())
  userId        String
  siteUrl       String
  siteName      String?
  apiKey        String   @unique
  version       String
  isActive      Boolean  @default(true)
  lastSeen      DateTime @default(now())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Relations
  user       User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  statistics Statistic[]
  
  @@map("installations")
}

// Statistic Model (Spam-Statistiken pro Installation)
model Statistic {
  id             String   @id @default(cuid())
  installationId String
  date           DateTime @default(now())
  
  // Counters
  totalBlocked   Int      @default(0)
  totalLegitimate Int     @default(0)
  blockedByType  Json?    // { "honeypot": 10, "timestamp": 5, ... }
  blockedByCountry Json?  // { "CN": 5, "RU": 3, ... }
  
  createdAt      DateTime @default(now())
  
  installation Installation @relation(fields: [installationId], references: [id], onDelete: Cascade)
  
  @@map("statistics")
}

// Global Stats (für Admin-Dashboard)
model GlobalStat {
  id                String   @id @default(cuid())
  date              DateTime @unique @default(now())
  totalInstallations Int     @default(0)
  activeInstallations Int    @default(0)
  totalBlocked      Int      @default(0)
  totalLegitimate   Int      @default(0)
  
  @@map("global_stats")
}

// Telemetry Event (Anonymisierte Spam-Daten für Muster-Erkennung)
// DSGVO-konform: Nur in Deutschland (Hetzner), nur zur Gefahrenabwehr
model TelemetryEvent {
  id              String   @id @default(cuid())
  installationId  String?  // Optional: Kann null sein wenn Installation gelöscht
  
  // Anonymisierte Daten
  ipHash          String   // SHA-256 Hash der IP (nicht umkehrbar)
  countryCode     String?  // ISO 2-letter code (DE, US, CN, ...)
  
  // Block-Details
  blockMethod     String   // honeypot, timestamp, geo, phrase, user_agent, ...
  blockReason     String?  // Detaillierter Grund
  
  // Spam-Indikatoren (KEINE persönlichen Daten!)
  emailDomainHash String?  // SHA-256 Hash nur der Domain (@example.com)
  spamDomains     Json?    // Array von Spam-Domains aus UA/Content
  userAgentHash   String?  // SHA-256 Hash des User-Agents
  
  // Metadata
  timestamp       DateTime @default(now())
  date            DateTime @default(now()) @db.Date // Für Aggregation
  
  // Indices für Performance
  @@index([installationId])
  @@index([countryCode])
  @@index([blockMethod])
  @@index([date])
  @@index([timestamp])
  
  @@map("telemetry_events")
}

// Invoice Model (Rechnungen für User)
model Invoice {
  id            String   @id @default(cuid())
  userId        String
  invoiceNumber String   @unique
  amount        Float
  currency      String   @default("EUR")
  status        InvoiceStatus @default(PAID)
  pdfUrl        String?  // URL zum PDF
  description   String?
  issuedAt      DateTime @default(now())
  dueAt         DateTime?
  paidAt        DateTime?
  createdAt     DateTime @default(now())
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([invoiceNumber])
  @@map("invoices")
}

enum InvoiceStatus {
  PAID
  PENDING
  OVERDUE
  CANCELLED
}

// Support Ticket Model
model SupportTicket {
  id          String   @id @default(cuid())
  userId      String
  subject     String
  category    TicketCategory
  message     String   @db.Text
  status      TicketStatus @default(OPEN)
  priority    TicketPriority @default(NORMAL)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  closedAt    DateTime?
  
  // Relations
  user        User @relation(fields: [userId], references: [id], onDelete: Cascade)
  attachments TicketAttachment[]
  responses   TicketResponse[]
  
  @@index([userId])
  @@index([status])
  @@index([category])
  @@map("support_tickets")
}

enum TicketCategory {
  FEHLER      // Bug/Fehler
  VORSCHLAG   // Feature-Vorschlag
  HILFE       // Hilfestellung
}

enum TicketStatus {
  OPEN
  IN_PROGRESS
  WAITING
  CLOSED
}

enum TicketPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

// Support Ticket Attachments (Bilder)
model TicketAttachment {
  id        String   @id @default(cuid())
  ticketId  String
  filename  String
  fileUrl   String
  fileSize  Int      // in bytes
  mimeType  String
  createdAt DateTime @default(now())
  
  ticket SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  
  @@index([ticketId])
  @@map("ticket_attachments")
}

// Ticket Responses (Admin-Antworten)
model TicketResponse {
  id        String   @id @default(cuid())
  ticketId  String
  authorId  String   // User ID (Admin oder User)
  message   String   @db.Text
  isAdmin   Boolean  @default(false)
  createdAt DateTime @default(now())
  
  ticket SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  
  @@index([ticketId])
  @@map("ticket_responses")
}

// News Model (Roadmap, Updates, Infos)
model News {
  id          String   @id @default(cuid())
  title       String
  content     String   @db.Text
  type        NewsType @default(INFO)
  isPublished Boolean  @default(false)
  publishedAt DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([isPublished])
  @@index([publishedAt])
  @@map("news")
}

enum NewsType {
  INFO        // Allgemeine Info
  UPDATE      // Plugin-Update
  ROADMAP     // Roadmap-Item
  MAINTENANCE // Wartungsarbeiten
}

// Plugin Release Model (für Downloads)
model PluginRelease {
  id          String   @id @default(cuid())
  version     String   @unique
  downloadUrl String
  changelog   String   @db.Text
  fileSize    Int      // in bytes
  isStable    Boolean  @default(true)
  releaseDate DateTime @default(now())
  createdAt   DateTime @default(now())
  
  @@index([version])
  @@index([isStable])
  @@map("plugin_releases")
}

// ============================================
// LIZENZ-SYSTEM (Jahres-Abos)
// ============================================

// License Model (Lizenzschlüssel)
model License {
  id              String        @id @default(cuid())
  userId          String
  licenseKey      String        @unique // Format: GFXX-XXXX-XXXX-XXXX
  packageType     PackageType
  
  // Lizenz-Status
  status          LicenseStatus @default(ACTIVE)
  isActive        Boolean       @default(true)
  
  // Zeitraum
  purchaseDate    DateTime      @default(now())
  expiresAt       DateTime      // Ablaufdatum (1 Jahr nach Kauf)
  lastRenewalDate DateTime?     // Letztes Verlängerungsdatum
  
  // Domain-Verwaltung
  maxDomains      Int           // 1, 5, 25 je nach Paket
  activeDomains   LicenseDomain[]
  
  // Payment
  molliePaymentId String?       // Mollie Payment ID
  invoiceId       String?       // Verknüpfung zur Rechnung
  
  // Metadata
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  // Relations
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([licenseKey])
  @@index([status])
  @@index([expiresAt])
  @@map("licenses")
}

enum PackageType {
  FREE        // 0€ - 1 Domain, Basis-Features
  SINGLE      // 29€/Jahr - 1 Domain, Alle Features
  FREELANCER  // 79€/Jahr - 5 Domains
  AGENCY      // 199€/Jahr - 25 Domains
}

enum LicenseStatus {
  ACTIVE      // Aktiv und gültig
  EXPIRED     // Abgelaufen (kann verlängert werden)
  SUSPENDED   // Gesperrt (z.B. bei Missbrauch)
  CANCELLED   // Gekündigt
}

// License Domain Model (Registrierte Domains pro Lizenz)
model LicenseDomain {
  id          String   @id @default(cuid())
  licenseId   String
  domain      String   // z.B. "example.com" (ohne http/https)
  
  // Aktivierung
  activatedAt DateTime @default(now())
  lastSeenAt  DateTime @default(now()) // Letzte Validierung vom Plugin
  
  // Metadata
  siteTitle   String?  // WordPress Site-Titel
  wpVersion   String?  // WordPress Version
  phpVersion  String?  // PHP Version
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  license     License  @relation(fields: [licenseId], references: [id], onDelete: Cascade)
  
  @@unique([licenseId, domain]) // Eine Domain kann nur einmal pro Lizenz registriert sein
  @@index([licenseId])
  @@index([domain])
  @@map("license_domains")
}

// License History (Verlängerungen, Änderungen)
model LicenseHistory {
  id          String   @id @default(cuid())
  licenseId   String
  action      LicenseAction
  description String?  @db.Text
  metadata    Json?    // Zusätzliche Daten
  createdAt   DateTime @default(now())
  
  @@index([licenseId])
  @@index([action])
  @@map("license_history")
}

enum LicenseAction {
  CREATED     // Lizenz erstellt
  RENEWED     // Verlängert
  EXPIRED     // Abgelaufen
  SUSPENDED   // Gesperrt
  REACTIVATED // Wieder aktiviert
  ACTIVATED   // Aktiviert (Admin)
  BLOCKED     // Gesperrt (Admin)
  CANCELLED   // Gekündigt
  DELETED     // Gelöscht (Admin)
  DOMAIN_ADDED    // Domain hinzugefügt
  DOMAIN_REMOVED  // Domain entfernt
}
